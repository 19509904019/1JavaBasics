一、super关键字的使用

    1.为什么需要super？
        子类继承父类以后，对父类的方法进行重写后调用的便是重写后的方法，如果想使用父类未被重写
        的方法，则使用super关键字进行调用。

    2.super可以调用的结构：属性、方法、构造器
      2.1 super调用属性、方法
        子类继承父类以后，我们就可以在子类的方法或构造器中，调用父类中声明的属性或方法（满足封装性的前提下）
        调用时需要使用"super."的结构，表示调用父类的属性或方法。
        一般情况下，我们可以考虑省略"super."的结构。但是如果出现子类重写了父类的方法或子父类有同名的属性时，
        则必须使用"super."的声明，显式的调用父类被重写的方法或父类中声明的同名的属性


      2.2 super调用构造器
        ①子类继承父类时，不会继承父类的构造器。只能通过"super(形参列表)"的方式调用父类指定的构造器
        ②规定："super(形参列表)"，必须声明在构造器的首行
        ③ 在构造器的首行，this(形参列表) 和 super(形参列表) 只能二选一
        ④如果在子类构造器的首行既没有显示调用"this(形参列表)"，也没有显示调用"super(形参列表)"，
          则子类子构造器默认调用"super()",即调用父类中空参的构造器（子类继承父类，所以创建实例的时候会先加载父类）
        ★⑤ 由③和④得到结论：子类调用任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器，只能
        是这两种情况之一。
        ⑥ 由⑤可知，一个类中声明的有n个构造器，最多有 n-1 个构造器中使用了"this(形参列表)"，则剩下的那个
        一定使用"super(形参列表)"

        ---> 我们在通过子类的构造器创建对象时，一定在调用子类构造器的过程中，直接或间接的调用到父类的构造器。
             也正因为调用过父类的构造器，我们才会将父类中声明的属性和方法加载到内存中，供子类对象使用

二、子类对象实例化全过程

    代码举例：
        class Creature{  // 生物类

        }

        class Animal extends Creature{  // 动物类

        }

        class Dog extends Animal{  // 狗类

        }

        class DogTest{
            public static void main(String[] args){
                Dog dog = new Dog();
                dog.xxx();
            }
        }

        1.从结果的角度来看，体现为继承性

        当我们创建子类对象后，子类对象就获取了其父类中声明的所有属性和方法，在权限
        允许的情况下，可以直接调用

        2.从过程的角度来看：
        当我们通过子类的构造器创建对象时，子类的构造器一定会直接或间接调用到其父类的构造器，
        而其父类的构造器同样会直接或间接调用到其父类的父类的构造器，...，直到调用到Object
        类中的构造器为止。

        3.创建子类对象的过程中，内存中就只有一个对象

































